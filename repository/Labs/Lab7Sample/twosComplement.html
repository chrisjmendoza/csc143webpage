<html>
<!-- Copyright 1997 Charles S. Tritt -->

<!-- Mirrored from seattlecentral.edu/faculty/flepeint/java143/Lab7Sample/twosComplement.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Jun 2015 00:10:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<title>2's Complement Arithmetic Document</title>
</head>
<body text="#000000" link="#0000cc" vlink="#a020a0" alink="#e00000"
bgcolor="#FFFFFF">
<h2 align="center">2's Complement Arithmetic</h2><hr>

<p>Here is a short list of 2's complement rules that I found at http://people.msoe.edu/~tritt/digtwosc.html.

<h3>Interpretations</h3><p>The typical way of generating 2's complement values is by inverting the bits and adding one to the
result.  For example, the four bit 2's complement form of -4<sub>10</sub>  would be generated by starting with
4<sub>10</sub> written in base 2, i.e. 0100, inverting the bits to give 1011 and adding one to give 1100.  You
must always pad the value being converted to the specified number of bits with zeros on the left
before inverting the bits and adding one.

<p>This process can also be used to determine a value in base 10.  For example, inverting the bits of
1100 gives 0011 and adding one results in 0100 which would be interpreted as -4<sub>10</sub>.  But there is
an alternate way to determine this value.  Interpret the left most (highest order) bit as the negative
of the corresponding power of 2.  For example, -(2<sup>3 </sup>) + 2<sup>2</sup> = -8 + 4 = -4<sub>10</sub>.  I 
find this second method easier and generally use it myself.

<h3>Sign Extension</h3><p>Since the left most bit is the sign bit and is interpreted differently from the others, the number of
bits used to represent a negative value in 2's complement form is very important.  For example, -4
as a 4-bit 2's complement value is 1100 as indicated above, as a 6-bit value it is 111100 (this can
be demonstrated by generating or interpreting the value as described above).

<p>In general, to increase the number of bits in a 2's complement representation extend the sign bit to
the left.  If the sign bit is a 1, all the bits added on the left are 1's.  On the other hand, if the sign
bit is a 0, all the added bits are 0's.

<h3>Arithmetic</h3><p>I'll be using 4 bit values in the rest of my examples.  For reference, these values are (you should
be able to generate this table yourself):
<p>

<table border cellpadding=2 width="100%">
<tr valign="baseline" align="center">
<td width="12%">2's Comp</td><td width="12%">Base 10</td><td width="12%">2's Comp</td><td width="12%">Base 10</td><td width="12%">2's Comp</td><td width="12%">Base 10</td><td width="12%">2's Comp</td><td width="12%">Base 10</td></tr>
<tr valign="baseline" align="center">
<td valign="top">1000</td><td valign="top">-8</td><td valign="top">1100</td><td valign="top">-4</td><td valign="top">0000</td><td valign="top">0</td><td valign="top">0100</td><td valign="top">4</td></tr>
<tr valign="baseline" align="center">
<td valign="top">1001</td><td valign="top">-7</td><td valign="top">1101</td><td valign="top">-3</td><td valign="top">0001</td><td valign="top">1</td><td valign="top">0101</td><td valign="top">5</td></tr>
<tr valign="baseline" align="center">
<td valign="top">1010</td><td valign="top">-6</td><td valign="top">1110</td><td valign="top">-2</td><td valign="top">0010</td><td valign="top">2</td><td valign="top">0110</td><td valign="top">6</td></tr>
<tr valign="baseline" align="center">
<td valign="top">1011</td><td valign="top">-5</td><td valign="top">1111</td><td valign="top">-1</td><td valign="top">0011</td><td valign="top">3</td><td valign="top">0111</td><td valign="top">7</td></tr>
</table><h3>Overflows</h3><dl>
<dt><p>Mixed signs always works -- <br>
<dd>5<sub>10</sub> - 3<sub>10</sub> = 5<sub>10</sub> + (-3<sub>10</sub>) = 0101 + 1101 = 1 | 0010 (ignore carry out of the sign bit) = 2<sub>10</sub>

<dd>3<sub>10</sub> - 5<sub>10</sub> = 3<sub>10</sub> + (-5<sub>10</sub>) = 0011 + 1011 = 1110 (no carry out of sign bit)  = -2<sub>10</sub>

<dt><p>Small, same sign works -- <br>
<dd>2<sub>10</sub> + 3<sub>10</sub> = 0010 + 0011 = 0101 (no carry out of sign bit) = 5<sub>10</sub>

<dd>-3<sub>10</sub> + (-2<sub>10</sub>) = 1101 + 1110 = 1 | 1011 (ignore carry out of sign bit) = -5<sub>10</sub>

<dt><p>Large, same sign doesn't work, but problem can be detected -- <br>
<dd>7<sub>10</sub> + 6<sub>10</sub> = 0111 + 0110 = 1101 = -3<sub>10</sub> (wrong)

<dd>-5<sub>10</sub> + (-4<sub>10</sub>) = 1011 + 1100 = 1 | 0111 = 7<sub>10</sub> (wrong)
</dl><p>Overflows can be detected by noting that the sign of the result differs from the sign of the two
terms.  This is clearly impossible.  Another way to detect this type of overflow is that the carry
into and out of the sign bit are always the same when overflow did not occur and are always
different when one did occur.
<hr>
</body>

<!-- Mirrored from seattlecentral.edu/faculty/flepeint/java143/Lab7Sample/twosComplement.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Jun 2015 00:10:30 GMT -->
</html>
